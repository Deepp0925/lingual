use strum::{EnumCount, EnumIter, EnumString, IntoEnumIterator};

use crate::AccurateLang;
/// The language codes supported by the API.
/// It is also possible to use strings like "en" or "fr" instead of the enum variants but it is not recommended
/// because it is not checked at compile time, therefore it is eliminated by default features.
/// To enable this feature, add `strings` to the features list of the crate.
/// get how many variants are there in the enum at compile time.
#[derive(
    Debug,
    PartialEq,
    Clone,
    Copy,
    Eq,
    PartialOrd,
    Ord,
    Hash,
    Default,
    EnumCount,
    EnumIter,
    EnumString,
    strum::Display,
    serde::Serialize,
    serde::Deserialize,
)]
#[cfg_attr(feature = "sqlx", derive(sqlx::Type))]
#[strum(serialize_all = "kebab-case")]
pub enum Lang {
    #[default]
    Auto,
    Af,
    Sq,
    Am,
    Ar,
    Hy,
    As,
    Ay,
    Az,
    Bm,
    Eu,
    Be,
    Bn,
    Bho,
    Bs,
    Bg,
    Ca,
    Ceb,
    ZhCn,
    ZhTw,
    Co,
    Hr,
    Cs,
    Da,
    Dv,
    Doi,
    Nl,
    En,
    Eo,
    Et,
    Ee,
    Tl,
    Fi,
    Fr,
    Fy,
    Gl,
    Ka,
    De,
    El,
    Gn,
    Gu,
    Ht,
    Ha,
    Haw,
    Iw,
    Hi,
    Hmn,
    Hu,
    Is,
    Ig,
    Ilo,
    Id,
    Ga,
    It,
    Ja,
    Jw,
    Kn,
    Kk,
    Km,
    Rw,
    Gom,
    Ko,
    Kri,
    Ku,
    Ckb,
    Ky,
    Lo,
    La,
    Lv,
    Lt,
    Lg,
    Lb,
    Mk,
    Mg,
    Mai,
    Ms,
    Ml,
    Mt,
    Mi,
    Mr,
    MniMtei,
    Lus,
    Mn,
    My,
    Ne,
    No,
    Ny,
    Or,
    Om,
    Ps,
    Fa,
    Pl,
    Pt,
    Pa,
    Qu,
    Ro,
    Ru,
    Sm,
    Sa,
    Gd,
    Nso,
    Sr,
    St,
    Sn,
    Sd,
    Si,
    Sk,
    Sl,
    So,
    Es,
    Su,
    Sw,
    Sv,
    // Tl,
    Tg,
    Ta,
    Tt,
    Te,
    Th,
    Ti,
    Ts,
    Tr,
    Tk,
    Ak,
    Uk,
    Ur,
    Ug,
    Uz,
    Vi,
    Cy,
    Xh,
    Yi,
    Yo,
    Zu,
}

impl Lang {
    pub const fn len() -> usize {
        Lang::COUNT
    }

    pub fn iter_() -> impl Iterator<Item = Self> {
        Lang::iter()
    }

    pub fn accurate_iter_() -> impl Iterator<Item = AccurateLang> {
        AccurateLang::iter()
    }

    ///checks if the provided lang can be converted to an accurate lang
    pub fn is_accurate_lang(&self) -> bool {
        AccurateLang::is_accurate_lang(self)
    }
    /// this is used to map the lang varient to the string(full) representation of the language
    /// for example: `Lang::En` => "English", `Lang::Fr` => "French", `Lang::Auto` => "Auto"
    pub fn fullname(&self) -> &str {
        match &self {
            Lang::Auto => "Auto",
            Lang::Af => "Afrikaans",
            Lang::Sq => "Albanian",
            Lang::Am => "Amharic",
            Lang::Ar => "Arabic",
            Lang::Hy => "Armenian",
            Lang::As => "Assamese",
            Lang::Ay => "Aymara",
            Lang::Az => "Azerbaijani",
            Lang::Bm => "Bambara",
            Lang::Eu => "Basque",
            Lang::Be => "Belarusian",
            Lang::Bn => "Bengali",
            Lang::Bho => "Bhojpuri",
            Lang::Bs => "Bosnian",
            Lang::Bg => "Bulgarian",
            Lang::Ca => "Catalan",
            Lang::Ceb => "Cebuano",
            Lang::ZhCn => "Chinese Simplified",
            Lang::ZhTw => "Chinese Traditional",
            Lang::Co => "Corsican",
            Lang::Hr => "Croatian",
            Lang::Cs => "Czech",
            Lang::Da => "Danish",
            Lang::Dv => "Divehi",
            Lang::Doi => "Dogri",
            Lang::Nl => "Dutch",
            Lang::En => "English",
            Lang::Eo => "Esperanto",
            Lang::Et => "Estonian",
            Lang::Ee => "Ewe",
            Lang::Tl => "Filipino",
            Lang::Fi => "Finnish",
            Lang::Fr => "French",
            Lang::Fy => "Frisian",
            Lang::Gl => "Galician",
            Lang::Ka => "Georgian",
            Lang::De => "German",
            Lang::El => "Greek",
            Lang::Gn => "Guarani",
            Lang::Gu => "Gujarati",
            Lang::Ht => "Haitian Creole",
            Lang::Ha => "Hausa",
            Lang::Haw => "Hawaiian",
            Lang::Iw => "Hebrew",
            Lang::Hi => "Hindi",
            Lang::Hmn => "Hmong",
            Lang::Hu => "Hungarian",
            Lang::Is => "Icelandic",
            Lang::Ig => "Igbo",
            Lang::Ilo => "Iloko",
            Lang::Id => "Indonesian",
            Lang::Ga => "Irish",
            Lang::It => "Italian",
            Lang::Ja => "Japanese",
            Lang::Jw => "Javanese",
            Lang::Kn => "Kannada",
            Lang::Kk => "Kazakh",
            Lang::Km => "Khmer",
            Lang::Rw => "Kinyarwanda",
            Lang::Gom => "Konkani",
            Lang::Ko => "Korean",
            Lang::Kri => "Krio (Sierra Leone)",
            Lang::Ku => "Kurdish",
            Lang::Ckb => "Kurdish (SoranÃ®)",
            Lang::Ky => "Kyrgyz",
            Lang::Lo => "Lao",
            Lang::La => "Latin",
            Lang::Lv => "Latvian",
            Lang::Lt => "Lithuanian",
            Lang::Lg => "Luganda",
            Lang::Lb => "Luxembourgish",
            Lang::Mk => "Macedonian",
            Lang::Mg => "Malagasy",
            Lang::Mai => "Maithili",
            Lang::Ms => "Malay",
            Lang::Ml => "Malayalam",
            Lang::Mt => "Maltese",
            Lang::Mi => "Maori",
            Lang::Mr => "Marathi",
            Lang::MniMtei => "Meitei",
            Lang::Lus => "Mizo",
            Lang::Mn => "Mongolian",
            Lang::My => "Myanmar (Burmese)",
            Lang::Ne => "Nepali",
            Lang::No => "Norwegian",
            Lang::Ny => "Nyanja (Chichewa)",
            Lang::Or => "Odia (Oriya)",
            Lang::Om => "Oromo",
            Lang::Ps => "Pashto",
            Lang::Fa => "Persian",
            Lang::Pl => "Polish",
            Lang::Pt => "Portuguese (Portugal, Brazil)",
            Lang::Pa => "Punjabi",
            Lang::Qu => "Quechua",
            Lang::Ro => "Romanian",
            Lang::Ru => "Russian",
            Lang::Sm => "Samoan",
            Lang::Gd => "Scots Gaelic",
            Lang::Sr => "Serbian",
            Lang::St => "Sesotho",
            Lang::Sn => "Shona",
            Lang::Sd => "Sindhi",
            Lang::Si => "Sinhala (Sinhalese)",
            Lang::Sk => "Slovak",
            Lang::Sl => "Slovenian",
            Lang::So => "Somali",
            Lang::Es => "Spanish",
            Lang::Su => "Sundanese",
            Lang::Sw => "Swahili",
            Lang::Sv => "Swedish",
            Lang::Tg => "Tajik",
            Lang::Ta => "Tamil",
            Lang::Tt => "Tatar",
            Lang::Te => "Telugu",
            Lang::Th => "Thai",
            Lang::Sa => "Sanskrit",
            Lang::Nso => "Northern Sotho",
            Lang::Ti => "Tigrinya",
            Lang::Ts => "Tsonga",
            Lang::Tr => "Turkish",
            Lang::Tk => "Turkmen",
            Lang::Ak => "Twi",
            Lang::Uk => "Ukrainian",
            Lang::Ur => "Urdu",
            Lang::Ug => "Uyghur",
            Lang::Uz => "Uzbek",
            Lang::Vi => "Vietnamese",
            Lang::Cy => "Welsh",
            Lang::Xh => "Xhosa",
            Lang::Yi => "Yiddish",
            Lang::Yo => "Yoruba",
            Lang::Zu => "Zulu",
        }
    }
}

pub trait OptionLangExt {
    /// returns the language if it is set, otherwise returns default src: `Lang::Auto`
    fn unwrap_or_default_src(&self) -> Lang;
    /// returns the language if it is set, otherwise returns default target: `Lang::En`
    fn unwrap_or_default_trgt(&self) -> Lang;
}

impl OptionLangExt for Option<Lang> {
    /// returns the language if it is set, otherwise returns default src: `Lang::Auto`
    fn unwrap_or_default_src(&self) -> Lang {
        match self {
            None => Lang::Auto,
            Some(l) => *l,
        }
    }
    /// returns the language if it is set, otherwise returns default target: `Lang::En`
    fn unwrap_or_default_trgt(&self) -> Lang {
        match self {
            None => Lang::En,
            Some(l) => *l,
        }
    }
}
